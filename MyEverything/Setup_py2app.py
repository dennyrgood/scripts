#!/usr/bin/env python3
"""
Generic macOS App Builder using py2app

This script creates a macOS .app bundle from any Python script using py2app in ALIAS mode.

ALIAS MODE (-A) is used because:
  - Faster builds (seconds vs minutes)
  - Easier to update (just edit the original Python script)
  - No code signing issues on modern macOS
  - Perfect for personal use

‚ö†Ô∏è  IMPORTANT WARNING ‚ö†Ô∏è
DO NOT MOVE YOUR PYTHON SCRIPT AFTER BUILDING THE APP!
The .app is a launcher that points to your script's current location.
If you move the script, the app will break and you'll need to rebuild.

Usage:
    ./build_mac_app.py MyScript.py
    ./build_mac_app.py path/to/MyScript.py
    
The script will:
  1. Generate a temporary setup.py
  2. Build MyScript.app in alias mode (-A)
  3. Place it in ./dist/
  4. Optionally move it to /Applications/

Examples:
    ./build_mac_app.py MyEverything.py
    ./build_mac_app.py ~/Documents/Calculator.py
"""

import sys
import os
import subprocess
import shlex
from pathlib import Path

def create_setup_py(script_path, packages=None):
    """
    Creates a temporary setup.py for py2app based on the input script.
    
    Args:
        script_path: Path to the Python script
        packages: List of additional packages to include (default: ['tkinter'])
    
    Returns:
        String containing the setup.py content
    """
    if packages is None:
        packages = ['tkinter']
    
    script_name = Path(script_path).name
    app_name = Path(script_path).stem  # Filename without extension
    
    # Create a nice display name (capitalize words, replace underscores)
    display_name = app_name.replace('_', ' ').title()
    
    # Create bundle identifier from app name
    bundle_id = f"com.local.{app_name.lower()}"
    
    # Format packages list for Python code
    packages_str = ','.join(f"'{pkg}'" for pkg in packages)
    
    setup_content = f'''"""
Temporary setup.py generated by build_mac_app.py
"""

from setuptools import setup

APP = ['{script_name}']
DATA_FILES = []

OPTIONS = {{
    'argv_emulation': False,
    'packages': [{packages_str}],
    'plist': {{
        'CFBundleName': '{app_name}',
        'CFBundleDisplayName': '{display_name}',
        'CFBundleGetInfoString': 'Python Application',
        'CFBundleIdentifier': '{bundle_id}',
        'CFBundleVersion': '1.0.0',
        'CFBundleShortVersionString': '1.0.0',
        'NSHumanReadableCopyright': 'Copyright ¬© 2025',
    }}
}}

setup(
    app=APP,
    data_files=DATA_FILES,
    options={{'py2app': OPTIONS}},
    setup_requires=['py2app'],
)
'''
    return setup_content


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    script_path = sys.argv[1]
    
    # Validate the script exists
    if not os.path.isfile(script_path):
        print(f"‚ùå Error: Script not found: {script_path}")
        sys.exit(1)
    
    # Get absolute path
    script_path = os.path.abspath(script_path)
    script_dir = os.path.dirname(script_path)
    script_name = os.path.basename(script_path)
    app_name = os.path.splitext(script_name)[0]
    
    print(f"üî® Building macOS app for: {script_name}")
    print(f"üìÅ Script location: {script_dir}")
    print(f"üì¶ App name: {app_name}.app")
    print()
    
    # Check if py2app is installed
    try:
        import py2app
    except ImportError:
        print("‚ùå py2app is not installed!")
        print("   Install it with: pip3 install py2app")
        sys.exit(1)
    
    # Additional packages - could be enhanced to auto-detect imports
    packages = ['tkinter']  # Default for GUI apps
    
    # Create temporary setup.py
    setup_content = create_setup_py(script_name, packages)
    setup_path = os.path.join(script_dir, 'setup_temp.py')
    
    try:
        # Write setup.py
        with open(setup_path, 'w') as f:
            f.write(setup_content)
        
        print("‚úÖ Generated temporary setup.py")
        
        # Change to script directory
        original_dir = os.getcwd()
        os.chdir(script_dir)
        
        # Clean previous builds
        print("üßπ Cleaning previous builds...")
        subprocess.run(['rm', '-rf', 'build', 'dist'], check=False)
        
        # Run py2app in ALIAS mode
        print("‚öôÔ∏è  Building app in ALIAS mode (this may take a moment)...")
        print()
        
        result = subprocess.run(
            [sys.executable, 'setup_temp.py', 'py2app', '-A'],
            capture_output=False  # Show output to user
        )
        
        if result.returncode != 0:
            print()
            print("‚ùå Build failed!")
            sys.exit(1)
        
        print()
        print("=" * 60)
        print("‚úÖ SUCCESS! App built successfully!")
        print("=" * 60)
        print()
        print(f"üì± App location: {script_dir}/dist/{app_name}.app")
        print()
        print("‚ö†Ô∏è  IMPORTANT REMINDER:")
        print(f"   DO NOT MOVE OR DELETE: {script_path}")
        print("   The .app is linked to this script's current location!")
        print("   If you move the script, you must rebuild the app.")
        print()
        
        # Ask if user wants to install to Applications
        response = input("üìÇ Install to /Applications/ folder? (y/n): ").strip().lower()
        
        if response == 'y':
            app_path = os.path.join(script_dir, 'dist', f'{app_name}.app')
            dest_path = f'/Applications/{app_name}.app'
            
            # Remove existing app if present
            if os.path.exists(dest_path):
                print(f"   Removing existing {app_name}.app from /Applications/")
                subprocess.run(['rm', '-rf', dest_path], check=False)
            
            subprocess.run(['mv', app_path, '/Applications/'], check=False)
            print(f"‚úÖ Installed to: /Applications/{app_name}.app")
            print("   You can now launch it from Spotlight or the Dock!")
        else:
            print(f"   App remains in: {script_dir}/dist/{app_name}.app")
            print(f"   You can test it with: open dist/{app_name}.app")
        
        print()
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)
    
    finally:
        # Cleanup
        os.chdir(original_dir)
        if os.path.exists(setup_path):
            os.remove(setup_path)
            print("üßπ Cleaned up temporary setup.py")


if __name__ == "__main__":
    main()
