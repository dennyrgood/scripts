#!/usr/bin/env python3
"""
dms - Document Management System Wrapper

Main CLI for managing Doc/ directories across repos.
Orchestrates scanning, image processing, AI summarization, and index updates.

REQUIREMENTS:
  - Must be run from the ROOT of a repository (not from subdirectories)
  - A Doc/ directory must exist in the repository root
  - The index.html file is stored in Doc/index.html

Usage (from repo root):
  dms scan              # Find new/changed files
  dms image-to-text     # Convert images to text
  dms summarize         # Generate AI summaries (dry-run by default)
  dms review            # Interactive approval
  dms apply             # Write approved changes to .dms_state.json
  dms cleanup           # Remove deleted files from state
  dms render            # Regenerate index.html from .dms_state.json
  dms auto              # Run full workflow (scan → image-to-text → summarize → review → apply)
  dms init              # Create new index.html for a fresh Doc/ directory
  dms status            # Show current state
"""
from __future__ import annotations
import argparse
import sys
from pathlib import Path
import json
import subprocess

# Expected structure when run from repo root:
# ./Doc/
# ./Doc/index.html (or to be created)
# ./Doc/md_outputs/

CONFIG_NAME = "dms_config.json"

def find_scripts_dir() -> Path:
    """Locate the Scripts directory (should be on PATH or known location)"""
    # Try common location first
    common = Path.home() / "Documents" / "MyWebsiteGIT" / "Scripts"
    if common.exists():
        return common
    
    # Try to find via PATH
    import shutil
    test_script = shutil.which("dms_scan.py")
    if test_script:
        return Path(test_script).parent
    
    print("ERROR: Cannot locate Scripts directory with DMS tools.", file=sys.stderr)
    print("Expected: ~/Documents/MyWebsiteGIT/Scripts", file=sys.stderr)
    sys.exit(1)

def load_config(scripts_dir: Path) -> dict:
    """Load configuration from Scripts/dms_config.json"""
    config_path = scripts_dir / CONFIG_NAME
    if not config_path.exists():
        # Create default config
        default = {
            "ollama_model": "qwen2.5-coder:14b",
            "ollama_host": "http://localhost:11434",
            "summary_max_words": 50,
            "temperature": 0.3,
            "enable_vision": False
        }
        config_path.write_text(json.dumps(default, indent=2), encoding='utf-8')
        print(f"Created default config at {config_path}")
        return default
    
    return json.loads(config_path.read_text(encoding='utf-8'))

def run_dms_script(script_name: str, args: list[str], scripts_dir: Path) -> int:
    """Execute a DMS script in the Scripts directory"""
    script_path = scripts_dir / script_name
    if not script_path.exists():
        print(f"ERROR: Script not found: {script_path}", file=sys.stderr)
        return 1
    
    cmd = [sys.executable, str(script_path)] + args
    result = subprocess.run(cmd)
    return result.returncode

def cmd_scan(args, scripts_dir: Path, config: dict):
    """Scan Doc/ for new or changed files"""
    print("==> Scanning Doc/ directory...")
    return run_dms_script("dms_util/dms_scan.py", ["--doc", "Doc"], scripts_dir)

def cmd_process_images(args, scripts_dir: Path, config: dict):
    """Convert images to text descriptions"""
    print("==> Processing images...")
    return run_dms_script("dms_util/dms_image_to_text.py", ["--doc", "Doc", "--md", "Doc/md_outputs"], scripts_dir)

def cmd_summarize(args, scripts_dir: Path, config: dict):
    """Generate AI summaries via Ollama"""
    print("==> Generating AI summaries...")
    dry_run = ["--dry-run"] if args.dry_run else []
    model = ["--model", args.model] if args.model else []
    return run_dms_script("dms_util/dms_summarize.py", 
                         ["--doc", "Doc"] + dry_run + model, 
                         scripts_dir)

def cmd_review(args, scripts_dir: Path, config: dict):
    """Interactive review of proposed changes"""
    print("==> Starting interactive review...")
    return run_dms_script("dms_util/dms_review.py", ["--doc", "Doc"], scripts_dir)

def cmd_apply(args, scripts_dir: Path, config: dict):
    """Apply approved changes to index.html"""
    print("==> Applying changes to index.html...")
    return run_dms_script("dms_util/dms_apply.py", ["--doc", "Doc"], scripts_dir)

def cmd_cleanup(args, scripts_dir: Path, config: dict):
    """Remove deleted files from index.html"""
    print("==> Cleaning up deleted files...")
    return run_dms_script("dms_util/dms_cleanup.py", ["--doc", "Doc"], scripts_dir)

def cmd_render(args, scripts_dir: Path, config: dict):
    """Regenerate index.html from .dms_state.json"""
    print("==> Regenerating index.html...")
    return run_dms_script("dms_util/dms_render.py", ["--doc", "Doc"], scripts_dir)

def cmd_auto(args, scripts_dir: Path, config: dict):
    """Run full workflow"""
    print("==> Running full DMS workflow...\n")
    
    steps = [
        ("Scan", lambda: cmd_scan(args, scripts_dir, config)),
        ("Process Images", lambda: cmd_process_images(args, scripts_dir, config)),
        ("Summarize", lambda: cmd_summarize(args, scripts_dir, config)),
        ("Review", lambda: cmd_review(args, scripts_dir, config)),
        ("Apply", lambda: cmd_apply(args, scripts_dir, config))
    ]
    
    for step_name, step_fn in steps:
        print(f"\n{'='*60}")
        print(f"Step: {step_name}")
        print('='*60)
        rc = step_fn()
        if rc != 0:
            print(f"\nERROR: {step_name} failed with code {rc}", file=sys.stderr)
            choice = input("Continue anyway? [y/N]: ").strip().lower()
            if choice != 'y':
                print("Workflow aborted.")
                return rc
    
    print("\n" + "="*60)
    print("DMS workflow complete!")
    print("="*60)
    return 0

def cmd_init(args, scripts_dir: Path, config: dict):
    """Initialize new index.html for a fresh Doc/ directory"""
    print("==> Initializing new Doc/index.html...")
    return run_dms_script("dms_util/dms_init.py", ["--doc", "Doc"], scripts_dir)

def cmd_status(args, scripts_dir: Path, config: dict):
    """Show current DMS state"""
    return run_dms_script("dms_util/dms_status.py", ["--doc", "Doc"], scripts_dir)

def cmd_delete_entry(args, scripts_dir: Path, config: dict):
    """Delete entries from state - launches interactive menu by default"""
    script_args = ["--doc", "Doc"]
    
    # If subcommand specified, build args for non-interactive mode
    if hasattr(args, 'del_action') and args.del_action:
        script_args.append(args.del_action)
        
        if args.del_action == "delete":
            script_args.append(args.path)
        elif args.del_action == "by-pattern":
            script_args.append(args.pattern)
            if hasattr(args, 'words_over') and args.words_over:
                script_args.append("--words-over")
                script_args.append(str(args.words_over))
    # else: no subcommand = interactive mode (default)
    
    return run_dms_script("dms_util/dms_delete_entry.py", script_args, scripts_dir)

def main():
    parser = argparse.ArgumentParser(
        prog="dms",
        description="Document Management System - Manage Doc/ directories with AI summaries"
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # scan
    subparsers.add_parser("scan", help="Scan for new/changed files")
    
    # image-to-text
    subparsers.add_parser("image-to-text", help="Convert images to text")
    
    # summarize
    p_sum = subparsers.add_parser("summarize", help="Generate AI summaries")
    p_sum.add_argument("--dry-run", action="store_true", help="Show proposed summaries without saving")
    p_sum.add_argument("--model", help="Override Ollama model (e.g., qwen2.5-coder:7b)")
    
    # review
    subparsers.add_parser("review", help="Interactive review of changes")
    
    # apply
    subparsers.add_parser("apply", help="Apply approved changes to index.html")
    
    # cleanup
    subparsers.add_parser("cleanup", help="Remove deleted files from index.html")
    
    # delete-entry
    p_del = subparsers.add_parser("delete-entry", help="Delete entries from state (interactive menu by default)")
    p_del_sub = p_del.add_subparsers(dest="del_action", help="Action (optional - omit for interactive mode)")
    p_del_sub.add_parser("list", help="List all entries (non-interactive)")
    p_del_delete = p_del_sub.add_parser("delete", help="Delete specific entry (non-interactive)")
    p_del_delete.add_argument("path", help="File path (e.g., './index.html')")
    p_del_pattern = p_del_sub.add_parser("by-pattern", help="Delete by pattern (non-interactive)")
    p_del_pattern.add_argument("pattern", help="Pattern to match")
    p_del_pattern.add_argument("--words-over", type=int, help="Only if summary > N words")
    
    # render
    subparsers.add_parser("render", help="Regenerate index.html from .dms_state.json")
    
    # auto
    subparsers.add_parser("auto", help="Run full workflow (scan → process → summarize → review → apply)")
    
    # init
    subparsers.add_parser("init", help="Create new index.html for fresh Doc/ directory")
    
    # status
    subparsers.add_parser("status", help="Show current DMS state")
    
    args = parser.parse_args()
    
    # Find scripts directory early (needed for menu)
    scripts_dir = find_scripts_dir()
    
    if not args.command:
        # Launch interactive menu
        menu_script = scripts_dir / "dms_menu.py"
        result = subprocess.run([sys.executable, str(menu_script)])
        return result.returncode
    
    # Check we're in a git repository
    cwd = Path.cwd()
    
    # Look for .git in current dir or parent dir (if we're in Doc/)
    has_git = (cwd / ".git").exists() or (cwd.parent / ".git").exists()
    
    if not has_git and args.command != "init":
        print("ERROR: DMS must be run from a git repository", file=sys.stderr)
        print("       (or from the Doc/ subdirectory of a git repository)", file=sys.stderr)
        print("", file=sys.stderr)
        print("Current directory: " + str(cwd), file=sys.stderr)
        print("", file=sys.stderr)
        print("To use DMS:", file=sys.stderr)
        print("  1. Navigate to a git repository root", file=sys.stderr)
        print("  2. Or navigate into the Doc/ directory", file=sys.stderr)
        print("  3. Run: dms <command>", file=sys.stderr)
        print("", file=sys.stderr)
        print("For a fresh repo, use: dms init", file=sys.stderr)
        return 1
    
    config = load_config(scripts_dir)
    
    commands = {
        "scan": cmd_scan,
        "image-to-text": cmd_process_images,
        "render": cmd_render,
        "summarize": cmd_summarize,
        "review": cmd_review,
        "apply": cmd_apply,
        "cleanup": cmd_cleanup,
        "auto": cmd_auto,
        "init": cmd_init,
        "status": cmd_status,
        "delete-entry": cmd_delete_entry
    }
    
    return commands[args.command](args, scripts_dir, config)

if __name__ == "__main__":
    sys.exit(main())
