#!/usr/bin/env python3
"""
Workflow to CSV Converter (Sub-graph Optimized)
Extracts prompt data from ComfyUI workflow JSON by mapping nodes to UI groups.
Filters out technical nodes like loaders, samplers, and file paths.
"""

import json
import csv
import argparse
import os
import re
from typing import List, Dict, Any

def get_node_category(node: Dict, groups: List[Dict]) -> str:
    """
    Determines the category of a node based on whether its position 
    falls within the bounds of a ComfyUI Group.
    """
    if not groups or 'pos' not in node or not isinstance(node.get('pos'), list):
        return "Uncategorized"

    try:
        nx, ny = node['pos']
    except (ValueError, TypeError):
        return "Uncategorized"
    
    best_group = "Uncategorized"
    min_area = float('inf')

    for group in groups:
        g_pos = group.get('pos')
        g_size = group.get('size')
        
        if not g_pos or not g_size:
            continue

        try:
            gx, gy = g_pos
            gw, gh = g_size
            
            # Check if node position is within group bounds
            if gx <= nx <= gx + gw and gy <= ny <= gy + gh:
                area = gw * gh
                if area < min_area:
                    min_area = area
                    title = group.get('title', 'General').strip()
                    best_group = title.rstrip(' -').strip()
        except (ValueError, TypeError):
            continue
            
    return best_group

def is_valid_prompt(text: str) -> bool:
    """
    Heuristic to filter out technical strings, paths, and model names.
    """
    t = text.strip()
    # Ignore empty or very short strings
    if len(t) < 15:
        return False
    # Ignore file paths/model paths (e.g., Qwen2509\...)
    if '\\' in t or '/' in t:
        return False
    # Ignore common model extensions
    if any(ext in t.lower() for ext in ['.safetensors', '.ckpt', '.pt', '.jpg', '.png']):
        return False
    # Ignore technical looking strings (no spaces or all caps underscores)
    if ' ' not in t and '_' in t:
        return False
        
    return True

def extract_prompts(data: Any) -> List[Dict[str, str]]:
    """
    Extracts prompts specifically from PrimitiveStringMultiline or Note nodes
    that are properly categorized within a Group.
    """
    extracted = []
    
    if not isinstance(data, dict):
        return extracted

    nodes = data.get('nodes', [])
    groups = data.get('groups', [])
    
    # We focus on the specific node types used for prompt libraries
    PROMPT_NODE_TYPES = {'PrimitiveStringMultiline', 'Note', 'Text Multiline'}

    for node in nodes:
        node_type = node.get('type')
        if node_type not in PROMPT_NODE_TYPES:
            continue

        # Get the category from the group
        category = get_node_category(node, groups)
        
        # We only want categorized library prompts
        if category == "Uncategorized":
            continue

        # Get the Title (the 'Modifier name')
        # In Fredy's library, this is always in Node name for S&R
        props = node.get('properties', {})
        title = props.get('Node name for S&R') or node.get('title')
        
        # If title is the same as the node type, it's likely a generic node, not a prompt
        if not title or title == node_type:
            continue

        # Find the text in widgets_values
        widgets = node.get('widgets_values', [])
        prompt_text = ""
        if isinstance(widgets, list):
            for w in widgets:
                if isinstance(w, str) and is_valid_prompt(w):
                    prompt_text = w.strip()
                    break
        
        if prompt_text:
            clean_title = str(title).replace("LIB:", "").strip()
            extracted.append({
                'category': category,
                'prompt_title': clean_title,
                'prompt': prompt_text
            })

    return extracted

def save_to_csv(data: List[Dict[str, str]], output_file: str):
    """Saves to CSV using QUOTE_ALL to match user sample."""
    keys = ['category', 'prompt_title', 'prompt']
    try:
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=keys, quoting=csv.QUOTE_ALL)
            writer.writerows(data)
        return True
    except Exception as e:
        print(f"Error saving CSV: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description="Extract Library prompts from ComfyUI JSON.")
    parser.add_argument("input", help="Path to the JSON file")
    parser.add_argument("-o", "--output", help="Output CSV path", default="extracted_prompts.csv")
    
    args = parser.parse_args()

    if not os.path.exists(args.input):
        print(f"Error: {args.input} not found.")
        return

    try:
        with open(args.input, 'r', encoding='utf-8') as f:
            workflow_data = json.load(f)
        
        print(f"Analyzing {args.input}...")
        results = extract_prompts(workflow_data)
        
        if not results:
            print("No library prompts found. (Check if nodes are inside Groups)")
            return

        if save_to_csv(results, args.output):
            print(f"Success! Extracted {len(results)} prompts.")
            
            stats = {}
            for r in results:
                stats[r['category']] = stats.get(r['category'], 0) + 1
            
            print("\nCategory Breakdown:")
            for cat, count in sorted(stats.items(), key=lambda x: x[1], reverse=True):
                print(f" - {cat}: {count} prompts")
        
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
